#include "pch.h"
#include "MigUtil.h"
#include "Controls.h"
#include "../core/Timer.h"

using namespace MigTech;
using namespace tinyxml2;

/////////////////////////////////////////////////////////////////////
// XML parsing helpers

static float parseFloat(XMLElement* elem, const char* attr, float def)
{
	const char* attrStr = elem->Attribute(attr);
	return MigUtil::parseFloat(attrStr, def);
}

static int parseInt(XMLElement* elem, const char* attr, int def)
{
	const char* attrStr = elem->Attribute(attr);
	return MigUtil::parseInt(attrStr, def);
}

static bool parseBool(XMLElement* elem, const char* attr, bool def)
{
	const char* attrStr = elem->Attribute(attr);
	return MigUtil::parseBool(attrStr, def);
}

static void parseFloats(XMLElement* elem, const char* attr, float* fVals, int len)
{
	const char* attrStr = elem->Attribute(attr);
	MigUtil::parseFloats(attrStr, fVals, len);
}

static JUSTIFY parseJustify(XMLElement* elem)
{
	const char* justifyStr = elem->Attribute("Justify");
	JUSTIFY justify = JUSTIFY_CENTER;
	if (!strcmp(justifyStr, "left"))
		justify = JUSTIFY_LEFT;
	else if (!strcmp(justifyStr, "right"))
		justify = JUSTIFY_RIGHT;
	return justify;
}

static Color parseColor(XMLElement* elem, const Color& def)
{
	const char* colorStr = elem->Attribute("Color");
	return MigUtil::parseColorString(colorStr, def);
}

/////////////////////////////////////////////////////////////////////
// basic button base class, won't do much so needs to be sub-classed

Button::Button(int id) : ControlBase(id),
	_enabled(true), _visible(true), _clickable(true), _color(MigTech::colWhite), _inflate(0),
	_animEnabled(true), _sendClickOnAnimComplete(false)
{
}

bool Button::init(XMLElement* xml, const Font* font)
{
	// ID (0 means the control can't be clicked)
	const char* attrStr = xml->Attribute("ID");
	if (attrStr != nullptr && !strcmp(attrStr, "back"))
		_id = ID_BACK_BUTTON;
	else
		_id = MigUtil::parseInt(attrStr, _id);

	// color
	Color color = parseColor(xml, _color);
	setColor(color);

	// visibility
	bool visible = parseBool(xml, "Visible", _visible);
	setVisible(visible);

	// enabled
	bool enabled = parseBool(xml, "Enabled", _enabled);
	setEnabled(enabled);

	// enabled
	bool clickable = parseBool(xml, "Clickable", _clickable);
	setClickable(clickable);

	// animation enabled
	bool animEnabled = parseBool(xml, "AnimEnabled", _animEnabled);
	setAnimEnabled(animEnabled);

	// hit rectangle inflation (will be applied when create() is called)
	_inflate = parseFloat(xml, "Inflate", _inflate);

	return isClickable();
}

void Button::create(IControlsCallback* callback)
{
	_callback = callback;

	// apply inflation if it was loaded via XML
	if (_inflate > 0)
		inflateHitRects(_inflate);
}

void Button::createGraphics()
{
}

void Button::destroyGraphics()
{
}

void Button::destroy()
{
}

void Button::draw(float alpha) const
{
}

void Button::draw(float alpha, const Matrix& worldMatrix) const
{
}

bool Button::pointerPressed(float x, float y)
{
	if (isClickable() && isEnabled() && isVisible() && _rect.Contains(x, y))
	{
		if (_animEnabled)
		{
			_idAnim.clearAnim();

			static float fs[] = { 1.0f, 0.93f, 0.91f, 0.9f };
			AnimItem animScale(this);
			animScale.configParametricAnim(0, 1, MigTech::defFastFadeDuration / 5, fs, ARRAYSIZE(fs));
			_idAnim = MigUtil::theAnimList->addItem(animScale, true);
		}

		return true;
	}

	return false;
}

void Button::pointerReleased(float x, float y)
{
	if (_animEnabled)
	{
		_idAnim.clearAnim();

		static float fs[] = { 0.9f, 0.91f, 0.93f, 1.0f };
		AnimItem animScale(this);
		animScale.configParametricAnim(0, 1, MigTech::defFastFadeDuration / 5, fs, ARRAYSIZE(fs));
		_idAnim = MigUtil::theAnimList->addItem(animScale, true);
	}
}

void Button::pointerMoved(float x, float y, bool isInContact)
{
}

bool Button::onTap(float x, float y)
{
	bool bHit = (isClickable() && isEnabled() && isVisible() && _rect.Contains(x, y));
	if (bHit)
	{
		if (_callback != nullptr)
		{
			// if a button animation is in progress, wait until it's done before sending the click
			if (_idAnim.isActive())
				_sendClickOnAnimComplete = true;
			else
			{
				LOGINFO("(Button::onTap) Click generated by %d", _id);
				_callback->onClick(_id, this);
			}
		}
	}
	return bHit;
}

bool Button::doFrame(int id, float newVal, void* optData)
{
	if (_idAnim == id)
	{
		_mat.identity();
		if (newVal < 1)
		{
			_mat.translate(-_offset.x, -_offset.y, -_offset.z);
			_mat.scale(newVal, newVal, 1);
			_mat.translate(_offset.x, _offset.y, _offset.z);
		}
	}
	return true;
}

void Button::animComplete(int id, void* optData)
{
	if (_idAnim == id)
	{
		//_mat.identity();
		_idAnim = 0;

		// if a tap came through while this animation was playing, send it up now
		if (_sendClickOnAnimComplete)
		{
			LOGINFO("(Button::animComplete) Click generated by %d", _id);
			_callback->onClick(_id, this);
		}
		_sendClickOnAnimComplete = false;
	}
}

Color Button::getDrawColor() const
{
	return (isEnabled() ? _color : Color(_color.r / 2, _color.g / 2, _color.b / 2, _color.a));
}

void Button::colorUpdated()
{
}

void Button::inflateHitRects(float radius)
{
	_rect.Inflate(radius, radius);
	_inflate = radius;
}

/////////////////////////////////////////////////////////////////////
// button defined by a piece of text and rectangle hit area

void TextButton::init(Text* text)
{
	_text = text;
	_rect = text->getScreenRect();
	_offset = MigUtil::screenPercentToCameraPlane(_rect.corner.x + _rect.size.width / 2, _rect.corner.y + _rect.size.height / 2);
}

void TextButton::init(const Font* font, const std::string& text, float u, float v, float h, float stretch, JUSTIFY justify)
{
	Text* textObj = font->createText();
	textObj->init(text, u, v, h, stretch, justify);
	init(textObj);
}

bool TextButton::init(XMLElement* xml, const Font* font)
{
	// note that an ID is optional
	Button::init(xml, font);

	const char* text = xml->Attribute("Text");
	if (text != nullptr)
	{
		float pos[3];
		parseFloats(xml, "Pos", pos, 3);
		float stretch = parseFloat(xml, "Stretch", 1);
		JUSTIFY justify = parseJustify(xml);
		init(font, MigUtil::getString(text, text), pos[0], pos[1], pos[2], stretch, justify);
		return true;
	}

	return false;
}

void TextButton::updateText(const std::string& newText, JUSTIFY justification)
{
	if (_text != nullptr)
		_text->update(newText, justification);
}

void TextButton::updatePos(float u, float v, float h, JUSTIFY justify)
{
	if (_text != nullptr)
	{
		std::string origText = _text->getText();
		_text->init(origText, u, v, h, 1, justify);
	}
}

void TextButton::destroy()
{
	if (_text != nullptr)
		_text->destroy();
}

void TextButton::draw(float alpha) const
{
	if (isVisible() && _text != nullptr)
	{
		Color drawColor = getDrawColor();
		_text->draw(drawColor.r, drawColor.g, drawColor.b, drawColor.a * alpha, _mat);
	}
}

void TextButton::draw(float alpha, const Matrix& worldMatrix) const
{
	if (isVisible() && _text != nullptr)
	{
		static Matrix newMat;
		newMat.copy(_mat);
		newMat.multiply(worldMatrix);

		Color drawColor = getDrawColor();
		_text->draw(drawColor.r, drawColor.g, drawColor.b, drawColor.a * alpha, newMat);
	}
}

/////////////////////////////////////////////////////////////////////
// button defined by a single texture map

void PicButton::init(const std::string& idTexture, float u, float v, float w, float h, float rot)
{
	// convert width and height from screen percent to camera plane values
	float width = MigUtil::screenPercentWidthToCameraPlane(w);
	float height = MigUtil::screenPercentHeightToCameraPlane(h);

	// create the movie clip, which will contain a single frame
	_mc.init(idTexture, width, height);

	// convert the center point from screen percentages to a point
	_offset = MigUtil::screenPercentToCameraPlane(u, v);
	_mc.setPos(_offset);
	_mc.setRot(0, 0, rot);

	_rect = MigUtil::screenPercentToRectangle(u, v, w, h);
}

bool PicButton::init(XMLElement* xml, const Font* font)
{
	if (Button::init(xml, font))
	{
		const char* image = xml->Attribute("Image");
		if (image != nullptr)
		{
			float pos[4];
			parseFloats(xml, "Pos", pos, 4);
			float rotate = parseFloat(xml, "Rotate", 0);
			init(image, pos[0], pos[1], pos[2], pos[3], MigUtil::convertToRadians(rotate));
			return true;
		}
	}

	return false;
}

void PicButton::colorUpdated()
{
	Color drawColor = getDrawColor();
	_mc.setColor(drawColor);
}

void PicButton::createGraphics()
{
	_mc.createGraphics();
}

void PicButton::destroyGraphics()
{
	_mc.destroyGraphics();
}

void PicButton::draw(float alpha) const
{
	if (isVisible())
		_mc.draw(_mat, false, alpha);
}

void PicButton::draw(float alpha, const Matrix& worldMatrix) const
{
	if (isVisible())
	{
		static Matrix newMat;
		newMat.copy(_mat);
		newMat.multiply(worldMatrix);

		_mc.draw(newMat, false, alpha);
	}
}

/////////////////////////////////////////////////////////////////////
// button defined by a single texture map and text centered inside

void PicTextButton::init(const Font* font, const std::string& text, const std::string& idTexture, float u, float v, float w, float h, float rot, float th)
{
	PicButton::init(idTexture, u, v, w, h, rot);

	if (font != nullptr && text.length() > 0)
	{
		// note that we assume the picture completely encloses the text
		_text = font->createText();
		_text->init(text, u, v + th / 2, th, JUSTIFY_CENTER);
	}
}

bool PicTextButton::init(tinyxml2::XMLElement* xml, const Font* font)
{
	if (PicButton::init(xml, font))
	{
		const char* text = xml->Attribute("Text");
		float th = parseFloat(xml, "Height", 0);
		float stretch = parseFloat(xml, "Stretch", 1);
		if (text != nullptr && th > 0)
		{
			// note that we assume the picture completely encloses the text
			_text = font->createText();
			_text->init(MigUtil::getString(text, text),
				_rect.corner.x + _rect.size.width / 2,
				_rect.corner.y + _rect.size.height / 2 + th / 2,
				th, stretch, JUSTIFY_CENTER);
			return true;
		}
	}

	return false;
}

void PicTextButton::draw(float alpha) const
{
	PicButton::draw(alpha);
	if (isVisible() && _text != nullptr)
	{
		Color drawColor = getDrawColor();
		_text->draw(drawColor.r, drawColor.g, drawColor.b, drawColor.a * alpha, _mat);
	}
}

void PicTextButton::draw(float alpha, const Matrix& worldMatrix) const
{
	PicButton::draw(alpha, worldMatrix);
	if (isVisible() && _text != nullptr)
	{
		static Matrix newMat;
		newMat.copy(_mat);
		newMat.multiply(worldMatrix);

		Color drawColor = getDrawColor();
		_text->draw(drawColor.r, drawColor.g, drawColor.b, drawColor.a * alpha, newMat);
	}
}

/////////////////////////////////////////////////////////////////////
// check box defined by a single texture map w/ two states stacked

void CheckBoxButton::init(const std::string& idTexture, float u, float v, float w, float h)
{
	// convert width and height from screen percent to camera plane values
	float width = MigUtil::screenPercentWidthToCameraPlane(w);
	float height = MigUtil::screenPercentHeightToCameraPlane(h);

	// create the movie clip, which will contain a single frame
	_mc.init(idTexture, 2, 1, width, height, false);

	// convert the center point from screen percentages to a point
	_mc.setPos(MigUtil::screenPercentToCameraPlane(u, v));

	_rect = MigUtil::screenPercentToRectangle(u, v, w, h);
}

void CheckBoxButton::init(const std::string& idTexture, float u, float v, float w, float h, const Font* font, const std::string& text, float th)
{
	// init checkbox portion
	init(idTexture, u, v, w, h);

	// init text portion, if used
	if (font != nullptr && text.length() > 0)
	{
		u += w;
		v += (th / 2);
		_text = font->createText();
		_text->init(text, u, v, th, JUSTIFY_LEFT);

		Rect rectText = _text->getScreenRect();
		_rect = Rect::Union(_rect, rectText);
	}
}

void CheckBoxButton::colorUpdated()
{
	Color drawColor = getDrawColor();
	_mc.setColor(drawColor);
}

bool CheckBoxButton::init(XMLElement* xml, const Font* font)
{
	if (Button::init(xml, font))
	{
		const char* image = xml->Attribute("Image");
		if (image != nullptr)
		{
			float pos[4];
			parseFloats(xml, "Pos", pos, 4);
			const char* text = xml->Attribute("Text");
			float height = parseFloat(xml, "Height", 0);
			if (text != nullptr && font != nullptr)
				init(image, pos[0], pos[1], pos[2], pos[3], font, MigUtil::getString(text, text), height);
			else
				init(image, pos[0], pos[1], pos[2], pos[3]);
			return true;
		}
	}

	return false;
}

void CheckBoxButton::createGraphics()
{
	_mc.createGraphics();
}

void CheckBoxButton::destroyGraphics()
{
	_mc.destroyGraphics();
}

void CheckBoxButton::draw(float alpha) const
{
	if (isVisible())
	{
		_mc.draw(alpha);

		if (_text != nullptr)
		{
			Color drawColor = getDrawColor();
			_text->draw(drawColor.r, drawColor.g, drawColor.b, drawColor.a * alpha);
		}
	}
}

void CheckBoxButton::draw(float alpha, const Matrix& worldMatrix) const
{
	if (isVisible())
	{
		_mc.draw(worldMatrix, false, alpha);

		if (_text != nullptr)
		{
			Color drawColor = getDrawColor();
			drawColor.a *= alpha;
			_text->draw(drawColor.r, drawColor.g, drawColor.b, drawColor.a, worldMatrix);
		}
	}
}

bool CheckBoxButton::onTap(float x, float y)
{
	bool bHit = (_enabled && _rect.Contains(x, y));
	if (bHit)
	{
		invertChecked();

		if (isClickable() && _callback != nullptr)
		{
			LOGINFO("(CheckBoxButton::onTap) Click generated by %d", _id);
			_callback->onClick(_id, this);
		}
	}
	return bHit;
}

/////////////////////////////////////////////////////////////////////
// slider control

void SliderButton::init(const std::string& idTextureBg, const std::string& idTextureSlider,
	float ubg, float vbg, float wbg, float hbg,
	float uleft, float uright, float v, float wslider, float hslider)
{
	// convert width and height from screen percent to camera plane values
	float width = MigUtil::screenPercentWidthToCameraPlane(wbg);
	float height = MigUtil::screenPercentHeightToCameraPlane(hbg);

	// create the background movie clip, which will contain a single frame
	_bgClip.init(idTextureBg, width, height);

	// convert the center point from screen percentages to a point
	Vector3 ptCenter = MigUtil::screenPercentToCameraPlane(ubg, vbg);
	_bgClip.setPos(ptCenter);

	// convert width and height from screen percent to camera plane values
	width = MigUtil::screenPercentWidthToCameraPlane(wslider);
	height = MigUtil::screenPercentHeightToCameraPlane(hslider);

	// create the slider movie clip, which will contain a single frame
	_sliderClip.init(idTextureSlider, width, height);

	// convert the center point from screen percentages to a point
	ptCenter = MigUtil::screenPercentToCameraPlane(uleft, v);
	_sliderClip.setPos(ptCenter);

	// default color
	_rect = MigUtil::screenPercentToRectangle(ubg, vbg, wbg, hbg);
	_rect.Inflate(0.05f, 0.05f);  // arbitrary for now
	_uSliderL = uleft; _uSliderR = uright; _vSlider = v;

	// init slider position to 0
	setSliderValue(0);
}

bool SliderButton::init(XMLElement* xml, const Font* font)
{
	if (Button::init(xml, font))
	{
		const char* image = xml->Attribute("Image");
		const char* slider = xml->Attribute("Slider");
		if (image != nullptr && slider != nullptr)
		{
			float pos[4], range[3], dimen[2];
			parseFloats(xml, "Pos", pos, 4);
			parseFloats(xml, "Range", range, 3);
			parseFloats(xml, "Dimen", dimen, 2);
			init(image, slider, pos[0], pos[1], pos[2], pos[3], range[0], range[1], range[2], dimen[0], dimen[1]);
			return true;
		}
	}

	return false;
}

void SliderButton::colorUpdated()
{
	Color drawColor = getDrawColor();
	_bgClip.setColor(drawColor);
	_sliderClip.setColor(drawColor);
}

void SliderButton::createGraphics()
{
	_bgClip.createGraphics();
	_sliderClip.createGraphics();
}

void SliderButton::destroyGraphics()
{
	_bgClip.destroyGraphics();
	_sliderClip.destroyGraphics();
}

void SliderButton::draw(float alpha) const
{
	if (isVisible())
	{
		// draw the background image
		_bgClip.draw(alpha);

		// draw the slider image
		_sliderClip.draw(alpha);
	}
}

void SliderButton::draw(float alpha, const Matrix& worldMatrix) const
{
	if (isVisible())
	{
		// draw the background image
		_bgClip.draw(worldMatrix, false, alpha);

		// draw the slider image
		_sliderClip.draw(worldMatrix, false, alpha);
	}
}

void SliderButton::updateSliderByScreenPosition(float x)
{
	// compute the new bounded value
	float newVal = (x - _uSliderL) / (_uSliderR - _uSliderL);
	if (newVal < 0)
		newVal = 0;
	else if (newVal > 1)
		newVal = 1;
	setSliderValue(newVal);

	// invoke the delegate
	if (isClickable() && _callback != nullptr)
		_callback->onSlide(_id, this, newVal);
}

bool SliderButton::pointerPressed(float x, float y)
{
	if (isEnabled() && isVisible())
	{
		_isSliding = _rect.Contains(x, y);
		if (_isSliding)
		{
			// start slider tracking
			updateSliderByScreenPosition(x);
		}
	}
	return _isSliding;
}

void SliderButton::pointerReleased(float x, float y)
{
	if (_isSliding)
	{
		updateSliderByScreenPosition(x);

		// note that we still consume the event if we were previously sliding
		_isSliding = false;
		if (isClickable() && _callback != nullptr)
		{
			LOGINFO("(SliderButton::pointerReleased) Click generated by %d", _id);
			_callback->onClick(_id, this);
		}
	}
}

void SliderButton::pointerMoved(float x, float y, bool isInContact)
{
	if (_isSliding && isInContact)
		updateSliderByScreenPosition(x);
}

void SliderButton::setSliderValue(float newVal)
{
	_sliderValue = newVal;

	// update the slider center point (world coordinates) for drawing
	float u = (_uSliderL + (_uSliderR - _uSliderL) * _sliderValue);
	Vector3 pos = MigUtil::screenPercentToCameraPlane(u, _vSlider);
	_sliderClip.setPos(pos);
}

/////////////////////////////////////////////////////////////////////
// controls container class

void Controls::addControl(ControlBase* control)
{
	if (control != nullptr)
	{
		control->create(_callback);
		_controls.push_back(control);
	}
}

void Controls::removeAllControls()
{
	std::vector<ControlBase*>::const_iterator iter = _controls.begin();
	while (iter != _controls.end())
	{
		if (*iter != nullptr)
		{
			(*iter)->destroy();
			delete (*iter);
		}
		iter++;
	}
	_controls.clear();
}

void Controls::loadFromXML(XMLElement* xml, const Font* theFont)
{
	if (theFont == nullptr)
		theFont = MigUtil::theFont;

	XMLElement* nextElement = xml->FirstChildElement();
	while (nextElement != nullptr)
	{
		const char* tag = nextElement->Name();

		if (!strcmp(tag, "StaticText"))
		{
			// static text
			TextButton* btn = new TextButton(0, false);
			if (btn->init(nextElement, theFont))
				addControl(btn);
			else
				delete btn;
		}
		else if (!strcmp(tag, "TextButton"))
		{
			// text buttons
			TextButton* btn = new TextButton(0);
			if (btn->init(nextElement, theFont))
				addControl(btn);
			else
				delete btn;
		}
		else if (!strcmp(tag, "PicButton"))
		{
			// picture buttons
			PicButton* btn = new PicButton(0);
			if (btn->init(nextElement, theFont))
				addControl(btn);
			else
				delete btn;
		}
		else if (!strcmp(tag, "PicTextButton"))
		{
			// picture/text buttons
			PicTextButton* btn = new PicTextButton(0);
			if (btn->init(nextElement, theFont))
				addControl(btn);
			else
				delete btn;
		}
		else if (!strcmp(tag, "CheckBoxButton"))
		{
			// checkbox buttons
			CheckBoxButton* btn = new CheckBoxButton(0);
			if (btn->init(nextElement, theFont))
				addControl(btn);
			else
				delete btn;
		}
		else if (!strcmp(tag, "SliderButton"))
		{
			// slider buttons
			SliderButton* btn = new SliderButton(0);
			if (btn->init(nextElement, theFont))
				addControl(btn);
			else
				delete btn;
		}
		else if (_callback != nullptr)
		{
			// custom controls
			ControlBase* ctrl = _callback->allocControl(tag);
			if (ctrl->init(nextElement, theFont))
				addControl(ctrl);
			else
				delete ctrl;
		}

		nextElement = nextElement->NextSiblingElement();
	}
}

void Controls::createGraphics()
{
	std::vector<ControlBase*>::const_iterator iter = _controls.begin();
	while (iter != _controls.end())
	{
		if (*iter != nullptr)
			(*iter)->createGraphics();
		iter++;
	}
}

void Controls::destroyGraphics()
{
	std::vector<ControlBase*>::const_iterator iter = _controls.begin();
	while (iter != _controls.end())
	{
		if (*iter != nullptr)
			(*iter)->destroyGraphics();
		iter++;
	}
}

void Controls::draw(float alpha) const
{
	std::vector<ControlBase*>::const_iterator iter = _controls.begin();
	while (iter != _controls.end())
	{
		if (*iter != nullptr)
			(*iter)->draw(alpha);
		iter++;
	}
}

void Controls::draw(float alpha, const Matrix& worldMatrix) const
{
	std::vector<ControlBase*>::const_iterator iter = _controls.begin();
	while (iter != _controls.end())
	{
		if (*iter != nullptr)
			(*iter)->draw(alpha, worldMatrix);
		iter++;
	}
}

bool Controls::pointerPressed(float x, float y)
{
	_inputLocked = nullptr;

	std::vector<ControlBase*>::const_iterator iter = _controls.begin();
	while (iter != _controls.end())
	{
		if (*iter != nullptr)
		{
			if ((*iter)->pointerPressed(x, y))
			{
				_inputLocked = *iter;
				return true;
			}
		}
		iter++;
	}
	return false;
}

void Controls::pointerReleased(float x, float y)
{
	if (_inputLocked)
		_inputLocked->pointerReleased(x, y);
}

void Controls::pointerMoved(float x, float y, bool isInContact)
{
	if (_inputLocked)
		_inputLocked->pointerMoved(x, y, isInContact);
}

bool Controls::onTap(float x, float y)
{
	std::vector<ControlBase*>::const_iterator iter = _controls.begin();
	while (iter != _controls.end())
	{
		if (*iter != nullptr)
		{
			if ((*iter)->onTap(x, y))
				return true;
		}
		iter++;
	}
	return false;
}

ControlBase* Controls::getControlByID(int id) const
{
	std::vector<ControlBase*>::const_iterator iter = _controls.begin();
	while (iter != _controls.end())
	{
		if (*iter != nullptr)
		{
			if ((*iter)->getID() == id)
				return (*iter);
		}
		iter++;
	}
	return nullptr;
}
